Schema                  ::=     Prolog Body

Prolog                  ::=     VersionDecl GlobalDirectives

VersionDecl             ::=     "version 1.0"

GlobalDirectives        ::=     SeparatorDirective? QuotedDirective? TotalColumnsExpr? (NoHeaderDirective | IgnoreColumnNameCaseDirective)?

DirectivePrefix         ::=     "@"

SeparatorDirective      ::=     DirectivePrefix "Separator" (TABExpr | SeparatorChar)
QuotedDirective         ::=     DirectivePrefix "Quoted"
TotalColumnsDirective   ::=     DirectivePrefix "TotalColumns" PositiveNonZeroIntegerLiteral
NoHeaderDirective       ::=     DirectivePrefix "NoHeader"
IgnoreColumnNameCase    ::=     DirectivePrefix "IgnoreColumnNameCase"

TABExpr                 ::=     "TAB" ("(" IntegerLiteral ")")?
SeparatorChar           ::=     CharacterLiteral

Body                    ::=     Comment* | ColumnDefinition+

Comment                 ::=     SingleLineComment | MultiLineComment
SingleLineComment       ::=     "//" NonBreakingChar*
MultiLineComment        ::=     "/*" Char* "*/"

ColumnDefinition        ::=     ColumnIdentifier ":" ColumnValidationExpr* ColumnDirectives
ColumnIdentifier        ::=     IntegerLiteral | Ident

ColumnValidationExpr    ::=     SingleExpr | ExternalSingleExpr | CombinatorialExpr | ParenthesizedExpr

SingleExpr              ::=     IsExpr | NotExpr | InExpr | StarstWithExpr | EndsWithExpr | RegExpExpr | NotEmptyExpr | UniqueExpr | UriExpr | XsdDateTimeExpr | XsdDateExpr | UkDateExpr | XsdTimeExpr | Uuid4Expr | PositiveIntegerExpr

IsExpr                  ::=     "is(" StringProvider ")"
NotExpr                 ::=     "not(" StringProvider ")"
InExpr                  ::=     "in(" StringProvider ")"
StartsWithExpr          ::=     "starts(" StringProvider ")"
EndsWithExpr            ::=     "ends(" StringProvider ")"
RegExpExpr              ::=     "regex(" StringLiteral ")"
NotEmptyExpr            ::=     "notEmpty"
UniqueExpr	            ::=     "unique"
UriExpr                 ::=     "uri"
XsdDateTimeExpr         ::=     "xDateTime"            
XsdDateExpr             ::=     "xDate"
UkDateExpr              ::=     "ukDate"
XsdTimeExpr             ::=     "xTime"
Uuid4Expr               ::=     "uuid4"
PositiveIntegerExpr     ::=     "positiveInteger"           /* [0-9]+ */

/* External expressions cause the checking of a value against some external source or process */
ExternalSingleExpr      ::=     FileExistsExpr | ChecksumExpr | FileCountExpr

FileExistsExpr          ::=     "fileExists" ("(" StringProvider ")")?                                              /* optional path to prepend to this cell with filename in */
ChecksumExpr            ::=     "checksum(" FileExpr "," StringLiteral ")"                                          /* first arg is file expr, second arg is algorithm to use for checksum */
FileCountExpr           ::=     "fileCount(" FileExpr ")"
FileExpr                ::=     "file(" (StringProvider ",")? (ColumnRef | FileNameExpr) ")"                        /* first (optional) arg is path (or ColumnRef of path) to prepend to second arg, second arg is reference to column containing filename, of a FileNameExpr */
FileNameExpr            ::=     StringLiteral

StringProvider          ::=     ColumnRef | StringLiteral

ColumnRef               ::=     "$" ColumnIdentifier

CombinatorialExpr       ::=     OrExpr | AndExpr
OrExpr                  ::=     ColumnValidatonExpr ("or" ColumnValidationExpr)*
AndExpr                 ::=     ColumnValidationExpr ("and" ColumnValidationExpr)*

ParenthesizedExpr       ::=     "(" ColumnValidationExpr ")"

/* Column Directives modify the behaviour of ColumnValidatonExpr(s) */
ColumnDirectives        ::=     IgnoreCaseDirective? MatchIsFalseDirective? NotEmpty? Unique?
IgnoreCaseDirective     ::=     DirectivePrefix "IgnoreCase"
MatchIsFalseDirective   ::=     DirectivePrefix "MatchIsFalse"
OptionalDirective       ::=     DirectivePrefix "Optional"


/* Lexical */
PositiveNonZeroIntegerLiteral           //IntegerLiteral constrained by [1-9]{1}[0-9]+
IntegerLiteral                          ::= Integer
CharacterLiteral                        ::= "'" NonBreakingChar "'"
StringLiteral                           ::= "\"" NonBreakingChar+ "\"" 
Ident                                   // [A-Za-z0-9\-_\.]+

Integer          
NonBreakingChar                         //same class as char but without \n or \r
Char
