Schema                  ::=     Prolog Body

Prolog                  ::=     VersionDecl GlobalDirectives

VersionDecl             ::=     "version 1.0"

/* Global Directives modify the global behaviour of CSV parsing and validation */
/* There are only five global directives (see the first line below), but they can appear in any of four orders, the following complexity deals with that */
GlobalDirectives        ::= (
    (SeparatorDirective? QuotedDirective? TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)?)
    | (QuotedDirective? SeparatorDirective? TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)?)
    | (TotalColumnsDirective? SeparatorDirective? QuotedDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)?)
    | ((NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective? QuotedDirective? TotalColumnsDirective)
    | (SeparatorDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? QuotedDirective? TotalColumnsDirective?)
    | (QuotedDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective? TotalColumnsDirective?)
    | (QuotedDirective? TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective?)
    | (TotalColumnsDirective? QuotedDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective?)
    | ((NoHeaderDirective | IgnoreColumnNameCaseDirective)? QuotedDirective? TotalColumnsDirective? SeparatorDirective?)
    | (TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective? QuotedDirective?)
    | ((NoHeaderDirective | IgnoreColumnNameCaseDirective)? TotalColumnsDirective? SeparatorDirective? QuotedDirective?)
    | (SeparatorDirective? TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? QuotedDirective?) 
)

DirectivePrefix         ::=     "@"

SeparatorDirective      ::=     DirectivePrefix "separator" (TABExpr | SeparatorChar)
QuotedDirective         ::=     DirectivePrefix "quoted"
TotalColumnsDirective   ::=     DirectivePrefix "totalColumns" PositiveNonZeroIntegerLiteral
NoHeaderDirective       ::=     DirectivePrefix "noHeader"
IgnoreColumnNameCase    ::=     DirectivePrefix "ignoreColumnNameCase"

TABExpr                 ::=     "TAB" ("(" IntegerLiteral ")")?
SeparatorChar           ::=     CharacterLiteral

Body                    ::=     BodyPart+
BodyPart                ::=     ((Comment* ColumnDefinition) | (ColumnDefinition Comment*))

Comment                 ::=     SingleLineComment | MultiLineComment
SingleLineComment       ::=     "//" NonBreakingChar*
MultiLineComment        ::=     "/*" Char* "*/"

ColumnDefinition        ::=     ColumnIdentifier ":" ColumnValidationExpr* ColumnDirectives
ColumnIdentifier        ::=     IntegerLiteral | Ident

ColumnValidationExpr    ::=     NonConditionalExpr | ConditionalExpr

NonConditionalExpr      ::=     SingleExpr | ExternalSingleExpr | CombinatorialExpr | ParenthesizedExpr

SingleExpr              ::=     IsExpr | NotExpr | InExpr | StarstWithExpr | EndsWithExpr | RegExpExpr | RangeExpr | LengthExpr | NotEmptyExpr | UniqueExpr | UriExpr | XsdDateTimeExpr | XsdDateExpr | UkDateExpr | XsdTimeExpr | Uuid4Expr | PositiveIntegerExpr

IsExpr                  ::=     "is(" StringProvider ")"
NotExpr                 ::=     "not(" StringProvider ")"
InExpr                  ::=     "in(" StringProvider ")"
StartsWithExpr          ::=     "starts(" StringProvider ")"
EndsWithExpr            ::=     "ends(" StringProvider ")"
RegExpExpr              ::=     "regex(" StringLiteral ")"
RangeExpr               ::=     "range(" NumericLiteral "," NumericLiteral ")"                                     /* range is inclusive */

/* length has 4 forms. 
    1) length(n) ensures the value is: the exact length n (absolute length)
    2) length(n, *) ensures the value is: longer than or equal to n (minimum length)
    3) length(*, n) ensures the value is: shorter than or equal to n (maximum length)
    4) length(n1, n2) ensures the value is: longer than or equal to n1 AND shorter than or equal to n2 (minumum and maximum lengths)
*/

LengthExpr              ::=     "length(" (PositiveIntegerLiteral | WildcardLiteral ",")? PositiveIntegerLiteral | WildcardLiteral ")"                 
NotEmptyExpr            ::=     "notEmpty"
UniqueExpr	            ::=     "unique"
UriExpr                 ::=     "uri"
XsdDateTimeExpr         ::=     "xDateTime"            
XsdDateExpr             ::=     "xDate"
UkDateExpr              ::=     "ukDate"
XsdTimeExpr             ::=     "xTime"
Uuid4Expr               ::=     "uuid4"
PositiveIntegerExpr     ::=     "positiveInteger"           /* [0-9]+ */

/* External expressions cause the checking of a value against some external source or process */
ExternalSingleExpr      ::=     FileExistsExpr | ChecksumExpr | FileCountExpr

FileExistsExpr          ::=     "fileExists" ("(" StringProvider ")")?                                              /* optional path to prepend to this cell with filename in */
ChecksumExpr            ::=     "checksum(" FileExpr "," StringLiteral ")"                                          /* first arg is file expr, second arg is algorithm to use for checksum */
FileCountExpr           ::=     "fileCount(" FileExpr ")"
FileExpr                ::=     "file(" (StringProvider ",")? (ColumnRef | FileNameExpr) ")"                        /* first (optional) arg is path (or ColumnRef of path) to prepend to second arg, second arg is reference to column containing filename, of a FileNameExpr */
FileNameExpr            ::=     StringLiteral

StringProvider          ::=     ColumnRef | StringLiteral

ColumnRef               ::=     "$" ColumnIdentifier

CombinatorialExpr       ::=     OrExpr | AndExpr
OrExpr                  ::=     ColumnValidatonExpr ("or" ColumnValidationExpr)*
AndExpr                 ::=     ColumnValidationExpr ("and" ColumnValidationExpr)*

ParenthesizedExpr       ::=     "(" ColumnValidationExpr ")"

ConditionalExpr         ::=     IfExpr

IfExpr                  ::=     "if(" NonConditionalExpr ")" "{" ColumnValidationExpr "}" ("else" "{" ColumnValidatorExpr "}")?        /* if with optional else */

/* Column Directives modify the behaviour of ColumnValidatonExpr(s) */
/* There are only three global directives (see the first line below), but they can appear in any of three orders, the following complexity deals with that */
ColumnDirectives        ::=     (
    (IgnoreCaseDirective? MatchIsFalseDirective? OptionalDirective?)
    | (MatchIsFalseDirective? IgnoreCaseDirective? OptionalDirective?)
    | (OptionalDirective? IgnoreCaseDirective? MatchIsFalseDirective?)
    | (IgnoreCaseDirective? OptionalDirective? MatchIsFalseDirective?)
    | (MatchIsFalseDirective? OptionalDirective? IgnoreCaseDirective?)
    | (OptionalDirective? MatchIsFalseDirective? IgnoreCaseDirective?)
)


IgnoreCaseDirective     ::=     DirectivePrefix "ignoreCase"
MatchIsFalseDirective   ::=     DirectivePrefix "matchIsFalse"
OptionalDirective       ::=     DirectivePrefix "optional"


/* Lexical */
PositiveNonZeroIntegerLiteral           /* A Natural Number - i.e. IntegerLiteral constrained by [1-9]{1}[0-9]+ */
PositiveIntegerLiteral                  /* A Natural Number or Zero - i.e. IntegerLiteral constrained by [0-9]{1}[0-9]+ */
NumericLiteral                          ::= Number
IntegerLiteral                          ::= Integer
CharacterLiteral                        ::= "'" NonBreakingChar "'"
StringLiteral                           ::= "\"" NonBreakingChar+ "\""
WildcardLiteral                         ::= "*" 
Ident                                   /* [A-Za-z0-9\-_\.]+ */

Number                                  /* Any Real Number expressed as an Integer or Decimal */
Integer                                 /* Any Non-Fractional and Non-Decimal Number */
NonBreakingChar                         /* same class as char but without \n or \r */
Char
