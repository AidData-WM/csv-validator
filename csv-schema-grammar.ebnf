Schema                  ::=     Prolog Body

Prolog                  ::=     VersionDecl GlobalDirectives

VersionDecl             ::=     "version 1.0"

/* Global Directives modify the global behaviour of CSV parsing and validation */
/* There are only five global directives (see the first line below), but they can appear in any of four orders, the following complexity deals with that */
GlobalDirectives        ::= (
    (SeparatorDirective? QuotedDirective? TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)?)
    | (QuotedDirective? SeparatorDirective? TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)?)
    | (TotalColumnsDirective? SeparatorDirective? QuotedDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)?)
    | ((NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective? QuotedDirective? TotalColumnsDirective)
    | (SeparatorDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? QuotedDirective? TotalColumnsDirective?)
    | (QuotedDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective? TotalColumnsDirective?)
    | (QuotedDirective? TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective?)
    | (TotalColumnsDirective? QuotedDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective?)
    | ((NoHeaderDirective | IgnoreColumnNameCaseDirective)? QuotedDirective? TotalColumnsDirective? SeparatorDirective?)
    | (TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? SeparatorDirective? QuotedDirective?)
    | ((NoHeaderDirective | IgnoreColumnNameCaseDirective)? TotalColumnsDirective? SeparatorDirective? QuotedDirective?)
    | (SeparatorDirective? TotalColumnsDirective? (NoHeaderDirective | IgnoreColumnNameCaseDirective)? QuotedDirective?) 
)

DirectivePrefix         ::=     "@"

SeparatorDirective      ::=     DirectivePrefix "separator" (TABExpr | SeparatorChar)
QuotedDirective         ::=     DirectivePrefix "quoted"
TotalColumnsDirective   ::=     DirectivePrefix "totalColumns" PositiveNonZeroIntegerLiteral
NoHeaderDirective       ::=     DirectivePrefix "noHeader"
IgnoreColumnNameCase    ::=     DirectivePrefix "ignoreColumnNameCase"

TABExpr                 ::=     "TAB" ("(" IntegerLiteral ")")?
SeparatorChar           ::=     CharacterLiteral

Body                    ::=     BodyPart+
BodyPart                ::=     ((Comment* ColumnDefinition) | (ColumnDefinition Comment*))

Comment                 ::=     SingleLineComment | MultiLineComment
SingleLineComment       ::=     "//" NonBreakingChar*
MultiLineComment        ::=     "/*" Char* "*/"

ColumnDefinition        ::=     ColumnIdentifier ":" ColumnValidationExpr* ColumnDirectives
ColumnIdentifier        ::=     IntegerLiteral | Ident

ColumnValidationExpr    ::=     NonConditionalExpr | ConditionalExpr

NonConditionalExpr      ::=     SingleExpr | ExternalSingleExpr | CombinatorialExpr | ParenthesizedExpr

SingleExpr              ::=     IsExpr | NotExpr | InExpr | StarstWithExpr | EndsWithExpr | RegExpExpr | NotEmptyExpr | UniqueExpr | UriExpr | XsdDateTimeExpr | XsdDateExpr | UkDateExpr | XsdTimeExpr | Uuid4Expr | PositiveIntegerExpr

IsExpr                  ::=     "is(" StringProvider ")"
NotExpr                 ::=     "not(" StringProvider ")"
InExpr                  ::=     "in(" StringProvider ")"
StartsWithExpr          ::=     "starts(" StringProvider ")"
EndsWithExpr            ::=     "ends(" StringProvider ")"
RegExpExpr              ::=     "regex(" StringLiteral ")"
NotEmptyExpr            ::=     "notEmpty"
UniqueExpr	            ::=     "unique"
UriExpr                 ::=     "uri"
XsdDateTimeExpr         ::=     "xDateTime"            
XsdDateExpr             ::=     "xDate"
UkDateExpr              ::=     "ukDate"
XsdTimeExpr             ::=     "xTime"
Uuid4Expr               ::=     "uuid4"
PositiveIntegerExpr     ::=     "positiveInteger"           /* [0-9]+ */

/* External expressions cause the checking of a value against some external source or process */
ExternalSingleExpr      ::=     FileExistsExpr | ChecksumExpr | FileCountExpr

FileExistsExpr          ::=     "fileExists" ("(" StringProvider ")")?                                              /* optional path to prepend to this cell with filename in */
ChecksumExpr            ::=     "checksum(" FileExpr "," StringLiteral ")"                                          /* first arg is file expr, second arg is algorithm to use for checksum */
FileCountExpr           ::=     "fileCount(" FileExpr ")"
FileExpr                ::=     "file(" (StringProvider ",")? (ColumnRef | FileNameExpr) ")"                        /* first (optional) arg is path (or ColumnRef of path) to prepend to second arg, second arg is reference to column containing filename, of a FileNameExpr */
FileNameExpr            ::=     StringLiteral

StringProvider          ::=     ColumnRef | StringLiteral

ColumnRef               ::=     "$" ColumnIdentifier

CombinatorialExpr       ::=     OrExpr | AndExpr
OrExpr                  ::=     ColumnValidatonExpr ("or" ColumnValidationExpr)*
AndExpr                 ::=     ColumnValidationExpr ("and" ColumnValidationExpr)*

ParenthesizedExpr       ::=     "(" ColumnValidationExpr ")"

ConditionalExpr         ::=     IfExpr

IfExpr                  ::=     "if(" NonConditionalExpr ")" "{" ColumnValidationExpr "}" ("else" "{" ColumnValidatorExpr "}")?        /* if with optional else */

/* Column Directives modify the behaviour of ColumnValidatonExpr(s) */
/* There are only three global directives (see the first line below), but they can appear in any of three orders, the following complexity deals with that */
ColumnDirectives        ::=     (
    (IgnoreCaseDirective? MatchIsFalseDirective? OptionalDirective?)
    | (MatchIsFalseDirective? IgnoreCaseDirective? OptionalDirective?)
    | (OptionalDirective? IgnoreCaseDirective? MatchIsFalseDirective?)
    | (IgnoreCaseDirective? OptionalDirective? MatchIsFalseDirective?)
    | (MatchIsFalseDirective? OptionalDirective? IgnoreCaseDirective?)
    | (OptionalDirective? MatchIsFalseDirective? IgnoreCaseDirective?)
)


IgnoreCaseDirective     ::=     DirectivePrefix "ignoreCase"
MatchIsFalseDirective   ::=     DirectivePrefix "matchIsFalse"
OptionalDirective       ::=     DirectivePrefix "optional"


/* Lexical */
PositiveNonZeroIntegerLiteral           //IntegerLiteral constrained by [1-9]{1}[0-9]+
IntegerLiteral                          ::= Integer
CharacterLiteral                        ::= "'" NonBreakingChar "'"
StringLiteral                           ::= "\"" NonBreakingChar+ "\"" 
Ident                                   // [A-Za-z0-9\-_\.]+

Integer          
NonBreakingChar                         //same class as char but without \n or \r
Char
